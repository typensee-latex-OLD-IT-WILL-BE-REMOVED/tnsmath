% == PACKAGES USED == %

\RequirePackage{commado}
\RequirePackage{etoolbox}

\RequirePackage{yhmath}
\RequirePackage{ifmtarg}
\RequirePackage{xstring}
\RequirePackage{forloop}


% == DEFINITIONS == %

% Sources :
%    * http://forum.mathematex.net/latex-f6/en-tete-de-ds-t12933.html#p124908
%    * http://forum.mathematex.net/latex-f6/derivee-avec-un-d-droit-et-espace-t12932.html#p124930
%    * http://forum.mathematex.net/latex-f6/remplacer-des-espaces-par-autre-chose-t12952.html#p125062
%    * http://forum.mathematex.net/latex-f6/probleme-de-remplacement-de-cdots-t13047.html#p125782


% dd, partial and pp useful operators
%
% Argument #1: the exponent
% Argument #2: the variable
% Argument #3: the operator
% Argument #4: space before exponent
% Argument #5: space after exponent

\newcommand{\@diffOpe}[5]{%
    #3%
    \ifx0#1\else%
    	^{\kern#4#1\kern#5}\!%
	\fi%
    \hspace{0.07em}#2%
}

\DeclareRobustCommand\@dder{
    \mathop{}\mathopen{}\mathrm{d}
}

\newcommand\dd[2][0]{\@diffOpe{#1}{#2}{\@dder}{.05ex}{0.15ex}}

\let\original@partial\partial
\renewcommand{\partial}{%
    \original@partial\mathopen{}%
}

\newcommand\pp[2][0]{\@diffOpe{#1}{#2}{\partial}{.15ex}{0.15ex}}



% Common tools

\newcounter{@der@prime@counter}

\newcommand\@der@func@no@par[1]{%
	#1%
}

\newcommand\@der@func@ext@par[1]{%
	\left( #1 \right)%
}

\newcommand\@der@func@no@ext@par[1]{%
	( #1 )%
}


\newbool{@der@option@u}
\newbool{@der@option@e}
\newbool{@der@option@i}
\newbool{@der@option@f}
\newbool{@der@option@of}
\newbool{@der@option@sf}
\newbool{@der@option@osf}
\newbool{@der@option@p}
\newbool{@der@option@sp}


% Total derivate

%     + Abstraction

\newcommand\@der@usual[3]{%
	#1{#2}^{%
		\,%
       	\forloop[1]{@der@prime@counter}{0}{\value{@der@prime@counter} < #3}{%
        	\prime%
        }
    }
}


\newcommand\@der@exp[3]{%
	#1{#2}^{\left( #3 \right)}%
}


\newcommand\@der@indice[3]{
    \@dder%
    \IfStrEq{#2}{1}{}{%
	    ^{\kern.15ex#2\kern.15ex}%
	}%
	_{\kern.15ex#3\kern.15ex} #1%
}


\newcommand\@der@abstract@frac[4]{%
	#1{%
		\IfStrEq{#3}{1}{%
			\dd{#2}%
		}{%
			\dd[#3]{#2}%
		}%
	}{%
		{%
			\dd{#4}%
			\IfStrEq{#3}{1}{}{%
				^{#3}%
			}%
		}%
	}%
}

\newcommand\@der@dfrac[3]{%
    \@der@abstract@frac{\dfrac}{#1}{#2}{#3}%
}

\newcommand\@der@frac[3]{
    \@der@abstract@frac{\frac}{#1}{#2}{#3}%
}

\newcommand\@der@ope@frac[3]{
    \@der@abstract@frac{\frac}{}{#2}{#3}#1%
}

\newcommand\@der@ope@dfrac[3]{
    \@der@abstract@frac{\dfrac}{}{#2}{#3}#1%
}


%     + Simple version (no var. of derivation)

\newcommand\@validate@simple@der@option[1]{
	\IfEqCase{#1}{%
		{u}{\booltrue{@der@option@u}}%
		{e}{\booltrue{@der@option@e}}%
		{p}{\booltrue{@der@option@p}}%
		{sp}{\booltrue{@der@option@sp}}%
	}[%
        \PackageError{lymath}{unknown option}%
                             {you can use u (default), e , p and sp}%
	]%
}


\newcommand\sder[3][u]{%
	\boolfalse{@der@option@u}%
	\boolfalse{@der@option@e}%
	\boolfalse{@der@option@p}%
	\boolfalse{@der@option@sp}%
	%
	\DoWithCSL\@validate@simple@der@option{#1}
	%
	\ifbool{@der@option@e}{}{%
		\booltrue{@der@option@u}%
	}%
	%
	\ifbool{@der@option@p}{%
		\let\parithere\@der@func@ext@par%
	}{%
		\ifbool{@der@option@sp}{%
			\let\parithere\@der@func@no@ext@par%
		}{%
			\let\parithere\@der@func@no@par%
		}%
	}%
	%
	\ifbool{@der@option@u}{%
		\let\callithere\@der@usual%
    }{%
		\let\callithere\@der@exp%
	}%
	\callithere{\parithere}{#2}{#3}%
}


%     + Strict version (this one needs the var. of derivation)

\newcommand\@validatee@der@option[1]{
	\IfEqCase{#1}{%
		{u}{\booltrue{@der@option@u}}%
		{e}{\booltrue{@der@option@e}}%
		{i}{\booltrue{@der@option@i}}%
		{f}{\booltrue{@der@option@f}}%
		{of}{\booltrue{@der@option@of}}%
		{sf}{\booltrue{@der@option@sf}}%
		{osf}{\booltrue{@der@option@osf}}%
		{p}{\booltrue{@der@option@p}}%
		{sp}{\booltrue{@der@option@sp}}%
	}[%
        \PackageError{lymath}{unknown option}%
                             {you can use u (default), e , i , f , sf , oi , of , osf , p and sp}%
	]%
}


\newcommand\der[4][u]{%
	\boolfalse{@der@option@u}%
	\boolfalse{@der@option@e}%
	\boolfalse{@der@option@i}%
	\boolfalse{@der@option@f}%
	\boolfalse{@der@option@of}%
	\boolfalse{@der@option@sf}%
	\boolfalse{@der@option@osf}%
	\boolfalse{@der@option@p}%
	\boolfalse{@der@option@sp}%
	%
	\DoWithCSL\@validatee@der@option{#1}
	%
	\ifboolexpr{
		not(
			bool {@der@option@e}
			or
			bool {@der@option@i}
			or
			bool {@der@option@f}
			or
			bool {@der@option@of}
			or
			bool {@der@option@sf}
			or
			bool {@der@option@osf}
		)
    }{%
    	\booltrue{@der@option@u}%
    }{}
	% Usual
	\ifbool{@der@option@u}{%
		\sder[#1]{#2}{#3}
	% Exponent
	}{
    	\ifbool{@der@option@e}{%
    		\sder[#1]{#2}{#3}
    	}{
    % Indice or fraction like
        	\ifbool{@der@option@p}{%
        		\let\parithere\@der@func@ext@par%
        	}{%
        		\ifbool{@der@option@sp}{%
        			\let\parithere\@der@func@no@ext@par%
        		}{%
        			\let\parithere\@der@func@no@par%
        		}%
        	}%
	 % Big frac
	 		\ifbool{@der@option@f}{%
				\let\callithere\@der@dfrac%
	 % Small frac
	 		}{%
				\ifbool{@der@option@sf}{%
					\let\callithere\@der@frac%
	 % Indice
	 			}{%
					\ifbool{@der@option@i}{%
						\let\callithere\@der@indice%
	% Big frac ope
					}{
						\ifbool{@der@option@of}{%
							\let\callithere\@der@ope@dfrac%
						}{
	% Small frac ope
							\ifbool{@der@option@osf}{%
								\let\callithere\@der@ope@frac%
							}{}%
						}%
					}%
				}%
	 		}%
	% Let's do the job
			\callithere{\parithere{#2}}{#3}{#4}%
		}%
	}%
}


%     + Operator for total derivations

\newcommand\@validate@der@operator@option[1]{
	\IfEqCase{#1}{%
		{f}{\booltrue{@der@option@f}}%
		{sf}{\booltrue{@der@option@sf}}%
		{i}{\booltrue{@der@option@i}}%
	}[%
        \PackageError{lymath}{unknown option}%
                             {you can use f (default), sf and i}%
	]%
}


\newcommand\derope[3][f]{%
	\boolfalse{@der@option@f}%
	\boolfalse{@der@option@sf}%
	\boolfalse{@der@option@i}%
	%
	\DoWithCSL\@validate@der@operator@option{#1}
	%
	\ifbool{@der@option@sf}{}{%
		\ifbool{@der@option@i}{}{%
			\booltrue{@der@option@f}%
		}%
	}%
	\der[#1]{}{#2}{#3}%
}



% Total derivate

%     + Abstraction

\newcommand\@pder@abstract@frac[4]{%
    #1{%
        \pp[#4]{#2}%
    }{%
% ARG 1 = Separator: |
% ARG 2 = All parts: what the user types !
% ARG 3 = Before   : nothing here
% ARG 4 = Between  : ;
% ARG 5 = After    : nothing here
        \makemultiargument{|}{#3}{\partial}{\,\partial}{}%
    }
}

\newcommand\@pder@dfrac[3]{%
	\@pder@abstract@frac{\dfrac}{#1}{#2}{#3}%
}

\newcommand\@pder@frac[3]{%
	\@pder@abstract@frac{\frac}{#1}{#2}{#3}%
}

\newcommand\@pder@ope@dfrac[3]{%
	\@pder@abstract@frac{\dfrac}{}{#2}{#3}#1%
}

\newcommand\@pder@ope@frac[3]{%
	\@pder@abstract@frac{\frac}{}{#2}{#3}#1%
}



\newcommand\@pder@sub[3]{
% The following command works because xstring traits {...} like a single character.
    \noexpandarg
    \StrSubstitute{#2}{^}{\@der@func@no@ext@par}[\@index]
    \partial%
    ^{\kern.15ex#3\kern.15ex}%
    _{\expandafter\StrSubstitute\expandafter{\@index}{|}{\,}}%
    #1%
    \expandarg
}


%     + With the function given

\newcommand\@validate@pder@option[1]{
	\IfEqCase{#1}{%
		{f}{\booltrue{@der@option@f}}%
		{of}{\booltrue{@der@option@of}}%
		{sf}{\booltrue{@der@option@sf}}%
		{osf}{\booltrue{@der@option@osf}}%
		{i}{\booltrue{@der@option@i}}%
		{p}{\booltrue{@der@option@p}}%
		{sp}{\booltrue{@der@option@sp}}%
	}[%
        \PackageError{lymath}{unknown option}%
                             {you can use f (default), sf, of, osf, i, p and sp}%
	]%
}


\newcommand\pder[4][f]{%
	\boolfalse{@der@option@f}%
	\boolfalse{@der@option@of}%
	\boolfalse{@der@option@sf}%
	\boolfalse{@der@option@osf}%
	\boolfalse{@der@option@i}%
	\boolfalse{@der@option@p}%
	\boolfalse{@der@option@sp}%
	%
	\DoWithCSL\@validate@pder@option{#1}
	%
	%
	\ifboolexpr{
		not(
			bool {@der@option@of}
			or
			bool {@der@option@sf}
			or
			bool {@der@option@osf}
			or
			bool {@der@option@i}
		)
    }{%
    	\booltrue{@der@option@f}%
    }{}%
    % Parentheses or not
    \ifbool{@der@option@p}{%
    	\let\parithere\@der@func@ext@par%
    }{%
    	\ifbool{@der@option@sp}{%
        	\let\parithere\@der@func@no@ext@par%
        }{%
        	\let\parithere\@der@func@no@par%
        }%
    }%
    % Expo total
    \IfStrEq{#4}{1}{%
    	\def\expotot{}
    }{%
    	\def\expotot{#4}
    }%
	% Big frac
	\ifbool{@der@option@f}{%
		\let\callithere\@pder@dfrac%
	}{%
    % Big frac ope
		\ifbool{@der@option@of}{%
			\let\callithere\@pder@ope@dfrac%
		}{%
	% Small frac
			\ifbool{@der@option@sf}{%
				\let\callithere\@pder@frac%
			}{%
	% Small frac ope
				\ifbool{@der@option@osf}{%
					\let\callithere\@pder@ope@frac%
				}{%
	% Indice
					\ifbool{@der@option@i}{%
						\let\callithere\@pder@sub%
					}{}%
				}%
			}%
		}%
	}%
	% Let's do the job
	\callithere{\parithere{#2}}{#3}{\expotot}%
}



%     + Operator for partiaal derivations

\newcommand\pderope[3][f]{%
	\boolfalse{@der@option@f}%
	\boolfalse{@der@option@sf}%
	\boolfalse{@der@option@i}%
	%
	\DoWithCSL\@validate@der@operator@option{#1}
	%
	\ifbool{@der@option@sf}{}{%
		\ifbool{@der@option@i}{}{%
			\booltrue{@der@option@f}%
		}%
	}%
	\pder[#1]{}{#2}{#3}%
}
